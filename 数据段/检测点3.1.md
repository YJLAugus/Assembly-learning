## 检测点3.1

### 题目一

1.在Debug 中,用"d 0:0 1f" 查看内存,结果如下:
0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 60
0000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88
下面的程序执行前,AX=0,BX=0,写出每条汇编指令执行完后相关寄存器中的值
mov ax,1
mov ds,ax
mov ax,[0000] ax= （）
mov bx,[0001] bx= （）
mov ax,bx ax= （）
mov ax,[0000] ax= （）
mov bx,[0002] bx= （）
add ax,bx ax= （）
add ax,[0004] ax= （）
mov ax,0 ax= （）
mov al,[0002] ax= （）
mov bx,0 bx= （）
mov bl,[000c] bx= （）
add al,bl ax= （）

#### 解析

```assembly
mov ax,1
mov ds,ax
mov ax,[0000] ax= 2662H
mov bx,[0001] bx= E626H
mov ax,bx ax= E626H
mov ax,[0000] ax= 2662H
mov bx,[0002] bx= D6E6H
add ax,bx ax= FD48H
add ax,[0004] ax= 2C14H
mov ax,0 ax= 0000H
mov al,[0002] ax= 00e6H
mov bx,0 bx= 0000H
mov bl,[000c] bx= 0026H
add al,bl ax= 000CH
```

整理这个题目是是因为这个题目虽然不难，但是却是整合了大量的知识点的。比如题目中的 `d 0:0 1f` 表示的意思是：`d 段地址:起始偏移地址 结束偏移地址` 也就是说 段地址从`0000H`开始 偏移地址从`0000H` 开始到`001f`结束，很明显偏移地址的范围是`0~1fH` 换算成10进制就是`0~31` 共`32`个**存储单元 = 32个字节 = 16个字**。从题目中可以看到正好是32个字节的。

```bash
 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 60
 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88
```

对于`0000:0000` 和`0000:0010` 前面四位是**段地址**，后面四位是**偏移地址**。好，接下来我们看下面的汇编指令，执行完前2行，此时ds = 0001H,也即段地址 = 0001H, 接下来执行第3行，即：将数据段（0001H）中偏移地址为0000H的**字**（注意这里是ax）加到ax中。换句话说：**将段地址ds为0001H中第一个字（偏移地址为0）加到ax中**。转到题目中就是`0001:0000` 。可是题目中没有这样一个**物理地址**。我们已经知道**物理地址 = 段地址 × 10H + 偏移地址**。其实，通过这个公式我们可以得出 其实 `0001;0000` 和`0000:0010` 指向的是同一个物理地址。

这里有一点要明确：**对某一个存储单元而言，它有唯一的物理地址，逻辑地址不是唯一的，可以有一个或多个。** 这也就说明白了为什么上面两个指向了同一个物理地址。接下来我们验证一下是不是“相等”。

```bash
0000:0010=00010
0001:0000=00010
地址表达式中前4位是段地址，后四位是偏移地址。
计算物理地址的公式是=段地址*10h+偏移地址
```

所以这两个是相同的。明白上面这些，下面简单的计算就简单了。举一个例子 mov ax，[0000] ，因为我们已经知道是在地址`0000:0010`中选择并计算 偏移地址为0000H,故第一个62 ，从低位到高位写 就是 ax = 2662H。下面也大多是如此。需要说明的是，注意最后一个add al,bl 千万不要写成010CH，题目是要求al,可不是ax,虽然要进位，但是al 可放不开。

